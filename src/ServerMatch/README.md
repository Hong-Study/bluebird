# 게임 서버의 프로젝트 개요이자 목표
- IOCP를 활용하여 대규모 인원이 참가할 수 있도록 게임 서버를 구축하여 보자
- 게임 입장, 움직임, 골인 등의 컨텐츠 내용을 경험해보기
- 코드를 끊임없이 되돌아보며 고칠 수 있는 코드를 찾고, 수정해보기

## 전체적인 로직
![image](https://user-images.githubusercontent.com/48054868/221213860-47de228c-fff0-4c94-8497-1a71a6fd941b.png)

## Protobuf 형태
- [ProtocolServer.proto](../../config/Protobuf/bin/InGame/ProtocolServer.proto)
- [ProtocolMatch.proto](../../config/Protobuf/bin/Match/ProtocolMatch.proto)

## 구현하며 사용한 기술들
- C++
- IOCP
- Protocol buffer

## 구현 기능
### 매치 입장
- 매치 입장
	- Redis DB에 해당 유저가 로그인 하였는지 확인
	- 각 유저의 모드에 맞는 매치 입장
	- 만약 유저가 모드를 다중으로 선택하였을 시, 가장 먼저 적정인원이 차게 되는 모드로 선택됨.
	- 다만 선착순으로 진행됨.

![image](https://user-images.githubusercontent.com/48054868/221222412-389c982a-d899-4c67-91ed-58a7ab3f8aa5.png)


### 매치 취소
- 매치 취소
	- 동작중인 매치를 취소함.
	- 만약 모드를 다중으로 선택한 상태일 경우, 모든 매치에서 제외함.

### 매치 성공
- 매치 성공 정보 전달
	- 정적인원이 차게되면, 해당 정보들을 패킷으로 만들어 ServerGame에게 전달

## 개발하면서 생긴 문제점
### 매치 매이킹 로직 설계
- 솔로, 듀오, 트리오 단일로 모드를 선택하는 것이 아니라 다중 체크가 가능하다 보니 SOLO, DUO, THREE, SOLO_DUO ... SOLO_DUO_THREE 코드를 다 작성
- 이렇게 하니 중복되는 코드들이 다량 발생

- 비트연산을 통해 중복되는 코드들을 줄일 수 있었습니다.
- SOLO = 1, DUO = 2, THREE = 4 를 기본으로 패킷 설계를 하여 비트 연산으로 다중 체크된 항목을 찾아 해당 매치 로직에 추가
- SOLO_DUO 는 3으로 SOLO & CHECk, DUO & CHECk 등의 코드로 일일이 비교하는 코드를 줄일 수 있었습니다.
```
if (level & SOLO)
	_playerSize[SOLO].fetch_add(1);
if (level & DUO)
	_playerSize[DUO].fetch_add(1);
if (level & THREE)
	_playerSize[THREE].fetch_add(1);
```

## 아쉬웠던 부분
- 솔로, 듀오, 트리오로 구성하여 코드를 구현하였지만 인게임(클라이언트) 구현 X
- 선착순으로 잡아 주다 보니, 다중 선택한 유저가 밀리는 현상 발생.
- 파이썬과 헤더를 연동하려다 보니 어려워 Protobuf로 헤더를 구현하였는데 ID의 크기에 따라서 Header크기가 변하는 문제점을 발견함. 그래서 특정 ID가 지나면 패킷 헤더 크기가 커져 파싱 불가능한 상황 발생.

## 느낀 점
- 비트연산으로 설계하고 사용해본 것은 이번 프로젝트가 처음이였습니다. 그 전까지는 왜 쓰는지도 몰랐고, 어떻게 사용해야 하는지 감도 안잡혀있었습니다. 그러나 이번 프로젝트를 통해 중복된 코드를 줄이고자 사용해보았는데 실제로 코드가 굉장히 간략해졌습니다. 이를 보면서 어떤 느낌으로 써야 하는지 조금 감을 잡아볼 수 있었고, 잘못 사용한다면 또한 문제가 될 수 있다는 것도 느낄 수 있었습니다.

## 앞으로의 길
- 매치 서버를 언제 다시 만들어볼 지는 모르겠지만, 추후에 제가 직접 게임을 만들 때 이번 프로젝트를 하면서 느꼈던 것들을 많이 활용해보려 합니다. (특히 비트연산 부분)
- 게임 서버 Readme에도 적었지만, 이번 프로젝트를 통해서 제가 얻고자 했던 것이 무엇이였는지, 왜 그렇게 정했었는지를 다시 한번 되돌아보려고 합니다. (특히 아키텍처 설계할 때 매치 서버나 NPC 서버를 나눈 이유 등에 대해)
