// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtocolServer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ProtocolServer_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ProtocolServer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ProtocolServer_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ProtocolServer_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ProtocolServer_2eproto;
namespace Protocol {
class ConnectData;
struct ConnectDataDefaultTypeInternal;
extern ConnectDataDefaultTypeInternal _ConnectData_default_instance_;
class GameCompleteData;
struct GameCompleteDataDefaultTypeInternal;
extern GameCompleteDataDefaultTypeInternal _GameCompleteData_default_instance_;
class Move;
struct MoveDefaultTypeInternal;
extern MoveDefaultTypeInternal _Move_default_instance_;
class MoveData;
struct MoveDataDefaultTypeInternal;
extern MoveDataDefaultTypeInternal _MoveData_default_instance_;
class Obtacle;
struct ObtacleDefaultTypeInternal;
extern ObtacleDefaultTypeInternal _Obtacle_default_instance_;
class Player;
struct PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class PlayerCrash;
struct PlayerCrashDefaultTypeInternal;
extern PlayerCrashDefaultTypeInternal _PlayerCrash_default_instance_;
class PlayerGoalData;
struct PlayerGoalDataDefaultTypeInternal;
extern PlayerGoalDataDefaultTypeInternal _PlayerGoalData_default_instance_;
class StartData;
struct StartDataDefaultTypeInternal;
extern StartDataDefaultTypeInternal _StartData_default_instance_;
class Times;
struct TimesDefaultTypeInternal;
extern TimesDefaultTypeInternal _Times_default_instance_;
class Vector;
struct VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::ConnectData* Arena::CreateMaybeMessage<::Protocol::ConnectData>(Arena*);
template<> ::Protocol::GameCompleteData* Arena::CreateMaybeMessage<::Protocol::GameCompleteData>(Arena*);
template<> ::Protocol::Move* Arena::CreateMaybeMessage<::Protocol::Move>(Arena*);
template<> ::Protocol::MoveData* Arena::CreateMaybeMessage<::Protocol::MoveData>(Arena*);
template<> ::Protocol::Obtacle* Arena::CreateMaybeMessage<::Protocol::Obtacle>(Arena*);
template<> ::Protocol::Player* Arena::CreateMaybeMessage<::Protocol::Player>(Arena*);
template<> ::Protocol::PlayerCrash* Arena::CreateMaybeMessage<::Protocol::PlayerCrash>(Arena*);
template<> ::Protocol::PlayerGoalData* Arena::CreateMaybeMessage<::Protocol::PlayerGoalData>(Arena*);
template<> ::Protocol::StartData* Arena::CreateMaybeMessage<::Protocol::StartData>(Arena*);
template<> ::Protocol::Times* Arena::CreateMaybeMessage<::Protocol::Times>(Arena*);
template<> ::Protocol::Vector* Arena::CreateMaybeMessage<::Protocol::Vector>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

enum INGAME : int {
  CONNECT = 0,
  START = 1,
  LEAVE = 2,
  PLAYER_MOVE = 3,
  OBSTACLE_MOVE = 4,
  GAME_COMPLTE = 5,
  GAME_END = 6,
  PLAYER_DROP = 7,
  PLAYER_CRASH = 8,
  CONNECT_FAIL = 9,
  TIME = 10,
  GET_TICK = 11,
  PLAYER_GOAL = 12,
  RECONNECT = 13,
  STATE_SYNC = 14,
  INGAME_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  INGAME_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool INGAME_IsValid(int value);
constexpr INGAME INGAME_MIN = CONNECT;
constexpr INGAME INGAME_MAX = STATE_SYNC;
constexpr int INGAME_ARRAYSIZE = INGAME_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* INGAME_descriptor();
template<typename T>
inline const std::string& INGAME_Name(T enum_t_value) {
  static_assert(::std::is_same<T, INGAME>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function INGAME_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    INGAME_descriptor(), enum_t_value);
}
inline bool INGAME_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, INGAME* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<INGAME>(
    INGAME_descriptor(), name, value);
}
enum Animation : int {
  IDLE = 0,
  MOVE = 1,
  JUMP_START = 2,
  JUMP_LOOP = 3,
  JUMP_END = 4,
  Animation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Animation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Animation_IsValid(int value);
constexpr Animation Animation_MIN = IDLE;
constexpr Animation Animation_MAX = JUMP_END;
constexpr int Animation_ARRAYSIZE = Animation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Animation_descriptor();
template<typename T>
inline const std::string& Animation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Animation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Animation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Animation_descriptor(), enum_t_value);
}
inline bool Animation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Animation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Animation>(
    Animation_descriptor(), name, value);
}
// ===================================================================

class PlayerGoalData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayerGoalData) */ {
 public:
  inline PlayerGoalData() : PlayerGoalData(nullptr) {}
  ~PlayerGoalData() override;
  explicit constexpr PlayerGoalData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerGoalData(const PlayerGoalData& from);
  PlayerGoalData(PlayerGoalData&& from) noexcept
    : PlayerGoalData() {
    *this = ::std::move(from);
  }

  inline PlayerGoalData& operator=(const PlayerGoalData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerGoalData& operator=(PlayerGoalData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerGoalData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerGoalData* internal_default_instance() {
    return reinterpret_cast<const PlayerGoalData*>(
               &_PlayerGoalData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PlayerGoalData& a, PlayerGoalData& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerGoalData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerGoalData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerGoalData* New() const final {
    return new PlayerGoalData();
  }

  PlayerGoalData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerGoalData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerGoalData& from);
  void MergeFrom(const PlayerGoalData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerGoalData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayerGoalData";
  }
  protected:
  explicit PlayerGoalData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PlayerGoalData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ProtocolServer_2eproto;
};
// -------------------------------------------------------------------

class GameCompleteData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.GameCompleteData) */ {
 public:
  inline GameCompleteData() : GameCompleteData(nullptr) {}
  ~GameCompleteData() override;
  explicit constexpr GameCompleteData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameCompleteData(const GameCompleteData& from);
  GameCompleteData(GameCompleteData&& from) noexcept
    : GameCompleteData() {
    *this = ::std::move(from);
  }

  inline GameCompleteData& operator=(const GameCompleteData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameCompleteData& operator=(GameCompleteData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameCompleteData& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameCompleteData* internal_default_instance() {
    return reinterpret_cast<const GameCompleteData*>(
               &_GameCompleteData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GameCompleteData& a, GameCompleteData& b) {
    a.Swap(&b);
  }
  inline void Swap(GameCompleteData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameCompleteData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameCompleteData* New() const final {
    return new GameCompleteData();
  }

  GameCompleteData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameCompleteData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameCompleteData& from);
  void MergeFrom(const GameCompleteData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameCompleteData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.GameCompleteData";
  }
  protected:
  explicit GameCompleteData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated .Protocol.PlayerGoalData data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::Protocol::PlayerGoalData* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerGoalData >*
      mutable_data();
  private:
  const ::Protocol::PlayerGoalData& _internal_data(int index) const;
  ::Protocol::PlayerGoalData* _internal_add_data();
  public:
  const ::Protocol::PlayerGoalData& data(int index) const;
  ::Protocol::PlayerGoalData* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerGoalData >&
      data() const;

  // @@protoc_insertion_point(class_scope:Protocol.GameCompleteData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerGoalData > data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ProtocolServer_2eproto;
};
// -------------------------------------------------------------------

class ConnectData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ConnectData) */ {
 public:
  inline ConnectData() : ConnectData(nullptr) {}
  ~ConnectData() override;
  explicit constexpr ConnectData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectData(const ConnectData& from);
  ConnectData(ConnectData&& from) noexcept
    : ConnectData() {
    *this = ::std::move(from);
  }

  inline ConnectData& operator=(const ConnectData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectData& operator=(ConnectData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectData* internal_default_instance() {
    return reinterpret_cast<const ConnectData*>(
               &_ConnectData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ConnectData& a, ConnectData& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConnectData* New() const final {
    return new ConnectData();
  }

  ConnectData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnectData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConnectData& from);
  void MergeFrom(const ConnectData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ConnectData";
  }
  protected:
  explicit ConnectData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRoomFieldNumber = 2,
    kLevelFieldNumber = 3,
  };
  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 room = 2;
  void clear_room();
  ::PROTOBUF_NAMESPACE_ID::int32 room() const;
  void set_room(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_room() const;
  void _internal_set_room(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 level = 3;
  void clear_level();
  ::PROTOBUF_NAMESPACE_ID::int32 level() const;
  void set_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_level() const;
  void _internal_set_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ConnectData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 room_;
  ::PROTOBUF_NAMESPACE_ID::int32 level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ProtocolServer_2eproto;
};
// -------------------------------------------------------------------

class StartData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.StartData) */ {
 public:
  inline StartData() : StartData(nullptr) {}
  ~StartData() override;
  explicit constexpr StartData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartData(const StartData& from);
  StartData(StartData&& from) noexcept
    : StartData() {
    *this = ::std::move(from);
  }

  inline StartData& operator=(const StartData& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartData& operator=(StartData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartData& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartData* internal_default_instance() {
    return reinterpret_cast<const StartData*>(
               &_StartData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StartData& a, StartData& b) {
    a.Swap(&b);
  }
  inline void Swap(StartData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartData* New() const final {
    return new StartData();
  }

  StartData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StartData& from);
  void MergeFrom(const StartData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.StartData";
  }
  protected:
  explicit StartData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 4,
    kObtacleFieldNumber = 5,
  };
  // repeated .Protocol.Player player = 4;
  int player_size() const;
  private:
  int _internal_player_size() const;
  public:
  void clear_player();
  ::Protocol::Player* mutable_player(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Player >*
      mutable_player();
  private:
  const ::Protocol::Player& _internal_player(int index) const;
  ::Protocol::Player* _internal_add_player();
  public:
  const ::Protocol::Player& player(int index) const;
  ::Protocol::Player* add_player();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Player >&
      player() const;

  // repeated .Protocol.Obtacle obtacle = 5;
  int obtacle_size() const;
  private:
  int _internal_obtacle_size() const;
  public:
  void clear_obtacle();
  ::Protocol::Obtacle* mutable_obtacle(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Obtacle >*
      mutable_obtacle();
  private:
  const ::Protocol::Obtacle& _internal_obtacle(int index) const;
  ::Protocol::Obtacle* _internal_add_obtacle();
  public:
  const ::Protocol::Obtacle& obtacle(int index) const;
  ::Protocol::Obtacle* add_obtacle();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Obtacle >&
      obtacle() const;

  // @@protoc_insertion_point(class_scope:Protocol.StartData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Player > player_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Obtacle > obtacle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ProtocolServer_2eproto;
};
// -------------------------------------------------------------------

class Times final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Times) */ {
 public:
  inline Times() : Times(nullptr) {}
  ~Times() override;
  explicit constexpr Times(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Times(const Times& from);
  Times(Times&& from) noexcept
    : Times() {
    *this = ::std::move(from);
  }

  inline Times& operator=(const Times& from) {
    CopyFrom(from);
    return *this;
  }
  inline Times& operator=(Times&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Times& default_instance() {
    return *internal_default_instance();
  }
  static inline const Times* internal_default_instance() {
    return reinterpret_cast<const Times*>(
               &_Times_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Times& a, Times& b) {
    a.Swap(&b);
  }
  inline void Swap(Times* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Times* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Times* New() const final {
    return new Times();
  }

  Times* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Times>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Times& from);
  void MergeFrom(const Times& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Times* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Times";
  }
  protected:
  explicit Times(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
  };
  // int64 time = 1;
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::int64 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Times)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ProtocolServer_2eproto;
};
// -------------------------------------------------------------------

class Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Move) */ {
 public:
  inline Move() : Move(nullptr) {}
  ~Move() override;
  explicit constexpr Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Move(const Move& from);
  Move(Move&& from) noexcept
    : Move() {
    *this = ::std::move(from);
  }

  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline Move& operator=(Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const Move* internal_default_instance() {
    return reinterpret_cast<const Move*>(
               &_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Move& a, Move& b) {
    a.Swap(&b);
  }
  inline void Swap(Move* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Move* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Move* New() const final {
    return new Move();
  }

  Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Move>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Move& from);
  void MergeFrom(const Move& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Move* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Move";
  }
  protected:
  explicit Move(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 4,
    kRotationFieldNumber = 5,
    kIdFieldNumber = 1,
    kTimeFieldNumber = 2,
    kAnimFieldNumber = 3,
  };
  // optional .Protocol.Vector position = 4;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Protocol::Vector& position() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::Vector* release_position();
  ::Protocol::Vector* mutable_position();
  void set_allocated_position(::Protocol::Vector* position);
  private:
  const ::Protocol::Vector& _internal_position() const;
  ::Protocol::Vector* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::Protocol::Vector* position);
  ::Protocol::Vector* unsafe_arena_release_position();

  // optional .Protocol.Vector rotation = 5;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::Protocol::Vector& rotation() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::Vector* release_rotation();
  ::Protocol::Vector* mutable_rotation();
  void set_allocated_rotation(::Protocol::Vector* rotation);
  private:
  const ::Protocol::Vector& _internal_rotation() const;
  ::Protocol::Vector* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::Protocol::Vector* rotation);
  ::Protocol::Vector* unsafe_arena_release_rotation();

  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 time = 2;
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::int64 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .Protocol.Animation anim = 3;
  void clear_anim();
  ::Protocol::Animation anim() const;
  void set_anim(::Protocol::Animation value);
  private:
  ::Protocol::Animation _internal_anim() const;
  void _internal_set_anim(::Protocol::Animation value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Protocol::Vector* position_;
  ::Protocol::Vector* rotation_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_;
  int anim_;
  friend struct ::TableStruct_ProtocolServer_2eproto;
};
// -------------------------------------------------------------------

class MoveData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MoveData) */ {
 public:
  inline MoveData() : MoveData(nullptr) {}
  ~MoveData() override;
  explicit constexpr MoveData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveData(const MoveData& from);
  MoveData(MoveData&& from) noexcept
    : MoveData() {
    *this = ::std::move(from);
  }

  inline MoveData& operator=(const MoveData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveData& operator=(MoveData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveData* internal_default_instance() {
    return reinterpret_cast<const MoveData*>(
               &_MoveData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MoveData& a, MoveData& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoveData* New() const final {
    return new MoveData();
  }

  MoveData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MoveData& from);
  void MergeFrom(const MoveData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MoveData";
  }
  protected:
  explicit MoveData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMoveFieldNumber = 2,
    kTimeFieldNumber = 1,
  };
  // repeated .Protocol.Move move = 2;
  int move_size() const;
  private:
  int _internal_move_size() const;
  public:
  void clear_move();
  ::Protocol::Move* mutable_move(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Move >*
      mutable_move();
  private:
  const ::Protocol::Move& _internal_move(int index) const;
  ::Protocol::Move* _internal_add_move();
  public:
  const ::Protocol::Move& move(int index) const;
  ::Protocol::Move* add_move();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Move >&
      move() const;

  // int64 time = 1;
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::int64 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.MoveData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Move > move_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ProtocolServer_2eproto;
};
// -------------------------------------------------------------------

class Obtacle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Obtacle) */ {
 public:
  inline Obtacle() : Obtacle(nullptr) {}
  ~Obtacle() override;
  explicit constexpr Obtacle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Obtacle(const Obtacle& from);
  Obtacle(Obtacle&& from) noexcept
    : Obtacle() {
    *this = ::std::move(from);
  }

  inline Obtacle& operator=(const Obtacle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Obtacle& operator=(Obtacle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Obtacle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Obtacle* internal_default_instance() {
    return reinterpret_cast<const Obtacle*>(
               &_Obtacle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Obtacle& a, Obtacle& b) {
    a.Swap(&b);
  }
  inline void Swap(Obtacle* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Obtacle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Obtacle* New() const final {
    return new Obtacle();
  }

  Obtacle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Obtacle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Obtacle& from);
  void MergeFrom(const Obtacle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Obtacle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Obtacle";
  }
  protected:
  explicit Obtacle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 3,
    kRotationFieldNumber = 4,
    kIdFieldNumber = 1,
    kShapeFieldNumber = 2,
    kSpeedFieldNumber = 5,
    kDirectionFieldNumber = 6,
  };
  // optional .Protocol.Vector position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Protocol::Vector& position() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::Vector* release_position();
  ::Protocol::Vector* mutable_position();
  void set_allocated_position(::Protocol::Vector* position);
  private:
  const ::Protocol::Vector& _internal_position() const;
  ::Protocol::Vector* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::Protocol::Vector* position);
  ::Protocol::Vector* unsafe_arena_release_position();

  // optional .Protocol.Vector rotation = 4;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::Protocol::Vector& rotation() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::Vector* release_rotation();
  ::Protocol::Vector* mutable_rotation();
  void set_allocated_rotation(::Protocol::Vector* rotation);
  private:
  const ::Protocol::Vector& _internal_rotation() const;
  ::Protocol::Vector* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::Protocol::Vector* rotation);
  ::Protocol::Vector* unsafe_arena_release_rotation();

  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 shape = 2;
  void clear_shape();
  ::PROTOBUF_NAMESPACE_ID::int32 shape() const;
  void set_shape(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_shape() const;
  void _internal_set_shape(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float speed = 5;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // int32 direction = 6;
  void clear_direction();
  ::PROTOBUF_NAMESPACE_ID::int32 direction() const;
  void set_direction(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_direction() const;
  void _internal_set_direction(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Obtacle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Protocol::Vector* position_;
  ::Protocol::Vector* rotation_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 shape_;
  float speed_;
  ::PROTOBUF_NAMESPACE_ID::int32 direction_;
  friend struct ::TableStruct_ProtocolServer_2eproto;
};
// -------------------------------------------------------------------

class Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  ~Player() override;
  explicit constexpr Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Player* New() const final {
    return new Player();
  }

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Player";
  }
  protected:
  explicit Player(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kRotationFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // optional .Protocol.Vector position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Protocol::Vector& position() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::Vector* release_position();
  ::Protocol::Vector* mutable_position();
  void set_allocated_position(::Protocol::Vector* position);
  private:
  const ::Protocol::Vector& _internal_position() const;
  ::Protocol::Vector* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::Protocol::Vector* position);
  ::Protocol::Vector* unsafe_arena_release_position();

  // optional .Protocol.Vector rotation = 3;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::Protocol::Vector& rotation() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::Vector* release_rotation();
  ::Protocol::Vector* mutable_rotation();
  void set_allocated_rotation(::Protocol::Vector* rotation);
  private:
  const ::Protocol::Vector& _internal_rotation() const;
  ::Protocol::Vector* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::Protocol::Vector* rotation);
  ::Protocol::Vector* unsafe_arena_release_rotation();

  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Protocol::Vector* position_;
  ::Protocol::Vector* rotation_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  friend struct ::TableStruct_ProtocolServer_2eproto;
};
// -------------------------------------------------------------------

class PlayerCrash final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayerCrash) */ {
 public:
  inline PlayerCrash() : PlayerCrash(nullptr) {}
  ~PlayerCrash() override;
  explicit constexpr PlayerCrash(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerCrash(const PlayerCrash& from);
  PlayerCrash(PlayerCrash&& from) noexcept
    : PlayerCrash() {
    *this = ::std::move(from);
  }

  inline PlayerCrash& operator=(const PlayerCrash& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerCrash& operator=(PlayerCrash&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerCrash& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerCrash* internal_default_instance() {
    return reinterpret_cast<const PlayerCrash*>(
               &_PlayerCrash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PlayerCrash& a, PlayerCrash& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerCrash* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerCrash* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerCrash* New() const final {
    return new PlayerCrash();
  }

  PlayerCrash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerCrash>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerCrash& from);
  void MergeFrom(const PlayerCrash& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerCrash* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayerCrash";
  }
  protected:
  explicit PlayerCrash(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kRotationFieldNumber = 3,
    kEnemyFieldNumber = 4,
    kIdFieldNumber = 1,
  };
  // .Protocol.Vector position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Protocol::Vector& position() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::Vector* release_position();
  ::Protocol::Vector* mutable_position();
  void set_allocated_position(::Protocol::Vector* position);
  private:
  const ::Protocol::Vector& _internal_position() const;
  ::Protocol::Vector* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::Protocol::Vector* position);
  ::Protocol::Vector* unsafe_arena_release_position();

  // .Protocol.Vector rotation = 3;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::Protocol::Vector& rotation() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::Vector* release_rotation();
  ::Protocol::Vector* mutable_rotation();
  void set_allocated_rotation(::Protocol::Vector* rotation);
  private:
  const ::Protocol::Vector& _internal_rotation() const;
  ::Protocol::Vector* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::Protocol::Vector* rotation);
  ::Protocol::Vector* unsafe_arena_release_rotation();

  // .Protocol.Player enemy = 4;
  bool has_enemy() const;
  private:
  bool _internal_has_enemy() const;
  public:
  void clear_enemy();
  const ::Protocol::Player& enemy() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::Player* release_enemy();
  ::Protocol::Player* mutable_enemy();
  void set_allocated_enemy(::Protocol::Player* enemy);
  private:
  const ::Protocol::Player& _internal_enemy() const;
  ::Protocol::Player* _internal_mutable_enemy();
  public:
  void unsafe_arena_set_allocated_enemy(
      ::Protocol::Player* enemy);
  ::Protocol::Player* unsafe_arena_release_enemy();

  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PlayerCrash)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::Vector* position_;
  ::Protocol::Vector* rotation_;
  ::Protocol::Player* enemy_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ProtocolServer_2eproto;
};
// -------------------------------------------------------------------

class Vector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Vector) */ {
 public:
  inline Vector() : Vector(nullptr) {}
  ~Vector() override;
  explicit constexpr Vector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector(const Vector& from);
  Vector(Vector&& from) noexcept
    : Vector() {
    *this = ::std::move(from);
  }

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector& operator=(Vector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
               &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Vector& a, Vector& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector* New() const final {
    return new Vector();
  }

  Vector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Vector";
  }
  protected:
  explicit Vector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Vector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ProtocolServer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlayerGoalData

// int64 id = 1;
inline void PlayerGoalData::clear_id() {
  id_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerGoalData::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerGoalData::id() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerGoalData.id)
  return _internal_id();
}
inline void PlayerGoalData::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void PlayerGoalData::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerGoalData.id)
}

// bool success = 2;
inline void PlayerGoalData::clear_success() {
  success_ = false;
}
inline bool PlayerGoalData::_internal_success() const {
  return success_;
}
inline bool PlayerGoalData::success() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerGoalData.success)
  return _internal_success();
}
inline void PlayerGoalData::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void PlayerGoalData::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerGoalData.success)
}

// -------------------------------------------------------------------

// GameCompleteData

// repeated .Protocol.PlayerGoalData data = 1;
inline int GameCompleteData::_internal_data_size() const {
  return data_.size();
}
inline int GameCompleteData::data_size() const {
  return _internal_data_size();
}
inline void GameCompleteData::clear_data() {
  data_.Clear();
}
inline ::Protocol::PlayerGoalData* GameCompleteData::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.GameCompleteData.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerGoalData >*
GameCompleteData::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.GameCompleteData.data)
  return &data_;
}
inline const ::Protocol::PlayerGoalData& GameCompleteData::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::Protocol::PlayerGoalData& GameCompleteData::data(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.GameCompleteData.data)
  return _internal_data(index);
}
inline ::Protocol::PlayerGoalData* GameCompleteData::_internal_add_data() {
  return data_.Add();
}
inline ::Protocol::PlayerGoalData* GameCompleteData::add_data() {
  // @@protoc_insertion_point(field_add:Protocol.GameCompleteData.data)
  return _internal_add_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerGoalData >&
GameCompleteData::data() const {
  // @@protoc_insertion_point(field_list:Protocol.GameCompleteData.data)
  return data_;
}

// -------------------------------------------------------------------

// ConnectData

// int64 id = 1;
inline void ConnectData::clear_id() {
  id_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ConnectData::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ConnectData::id() const {
  // @@protoc_insertion_point(field_get:Protocol.ConnectData.id)
  return _internal_id();
}
inline void ConnectData::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void ConnectData::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.ConnectData.id)
}

// int32 room = 2;
inline void ConnectData::clear_room() {
  room_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConnectData::_internal_room() const {
  return room_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConnectData::room() const {
  // @@protoc_insertion_point(field_get:Protocol.ConnectData.room)
  return _internal_room();
}
inline void ConnectData::_internal_set_room(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  room_ = value;
}
inline void ConnectData::set_room(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_room(value);
  // @@protoc_insertion_point(field_set:Protocol.ConnectData.room)
}

// int32 level = 3;
inline void ConnectData::clear_level() {
  level_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConnectData::_internal_level() const {
  return level_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConnectData::level() const {
  // @@protoc_insertion_point(field_get:Protocol.ConnectData.level)
  return _internal_level();
}
inline void ConnectData::_internal_set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  level_ = value;
}
inline void ConnectData::set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.ConnectData.level)
}

// -------------------------------------------------------------------

// StartData

// repeated .Protocol.Player player = 4;
inline int StartData::_internal_player_size() const {
  return player_.size();
}
inline int StartData::player_size() const {
  return _internal_player_size();
}
inline void StartData::clear_player() {
  player_.Clear();
}
inline ::Protocol::Player* StartData::mutable_player(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.StartData.player)
  return player_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Player >*
StartData::mutable_player() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.StartData.player)
  return &player_;
}
inline const ::Protocol::Player& StartData::_internal_player(int index) const {
  return player_.Get(index);
}
inline const ::Protocol::Player& StartData::player(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.StartData.player)
  return _internal_player(index);
}
inline ::Protocol::Player* StartData::_internal_add_player() {
  return player_.Add();
}
inline ::Protocol::Player* StartData::add_player() {
  // @@protoc_insertion_point(field_add:Protocol.StartData.player)
  return _internal_add_player();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Player >&
StartData::player() const {
  // @@protoc_insertion_point(field_list:Protocol.StartData.player)
  return player_;
}

// repeated .Protocol.Obtacle obtacle = 5;
inline int StartData::_internal_obtacle_size() const {
  return obtacle_.size();
}
inline int StartData::obtacle_size() const {
  return _internal_obtacle_size();
}
inline void StartData::clear_obtacle() {
  obtacle_.Clear();
}
inline ::Protocol::Obtacle* StartData::mutable_obtacle(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.StartData.obtacle)
  return obtacle_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Obtacle >*
StartData::mutable_obtacle() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.StartData.obtacle)
  return &obtacle_;
}
inline const ::Protocol::Obtacle& StartData::_internal_obtacle(int index) const {
  return obtacle_.Get(index);
}
inline const ::Protocol::Obtacle& StartData::obtacle(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.StartData.obtacle)
  return _internal_obtacle(index);
}
inline ::Protocol::Obtacle* StartData::_internal_add_obtacle() {
  return obtacle_.Add();
}
inline ::Protocol::Obtacle* StartData::add_obtacle() {
  // @@protoc_insertion_point(field_add:Protocol.StartData.obtacle)
  return _internal_add_obtacle();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Obtacle >&
StartData::obtacle() const {
  // @@protoc_insertion_point(field_list:Protocol.StartData.obtacle)
  return obtacle_;
}

// -------------------------------------------------------------------

// Times

// int64 time = 1;
inline void Times::clear_time() {
  time_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Times::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Times::time() const {
  // @@protoc_insertion_point(field_get:Protocol.Times.time)
  return _internal_time();
}
inline void Times::_internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  time_ = value;
}
inline void Times::set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:Protocol.Times.time)
}

// -------------------------------------------------------------------

// Move

// int64 id = 1;
inline void Move::clear_id() {
  id_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Move::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Move::id() const {
  // @@protoc_insertion_point(field_get:Protocol.Move.id)
  return _internal_id();
}
inline void Move::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void Move::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.Move.id)
}

// int64 time = 2;
inline void Move::clear_time() {
  time_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Move::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Move::time() const {
  // @@protoc_insertion_point(field_get:Protocol.Move.time)
  return _internal_time();
}
inline void Move::_internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  time_ = value;
}
inline void Move::set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:Protocol.Move.time)
}

// .Protocol.Animation anim = 3;
inline void Move::clear_anim() {
  anim_ = 0;
}
inline ::Protocol::Animation Move::_internal_anim() const {
  return static_cast< ::Protocol::Animation >(anim_);
}
inline ::Protocol::Animation Move::anim() const {
  // @@protoc_insertion_point(field_get:Protocol.Move.anim)
  return _internal_anim();
}
inline void Move::_internal_set_anim(::Protocol::Animation value) {
  
  anim_ = value;
}
inline void Move::set_anim(::Protocol::Animation value) {
  _internal_set_anim(value);
  // @@protoc_insertion_point(field_set:Protocol.Move.anim)
}

// optional .Protocol.Vector position = 4;
inline bool Move::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || position_ != nullptr);
  return value;
}
inline bool Move::has_position() const {
  return _internal_has_position();
}
inline void Move::clear_position() {
  if (position_ != nullptr) position_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Protocol::Vector& Move::_internal_position() const {
  const ::Protocol::Vector* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector&>(
      ::Protocol::_Vector_default_instance_);
}
inline const ::Protocol::Vector& Move::position() const {
  // @@protoc_insertion_point(field_get:Protocol.Move.position)
  return _internal_position();
}
inline void Move::unsafe_arena_set_allocated_position(
    ::Protocol::Vector* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.Move.position)
}
inline ::Protocol::Vector* Move::release_position() {
  _has_bits_[0] &= ~0x00000001u;
  ::Protocol::Vector* temp = position_;
  position_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::Vector* Move::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:Protocol.Move.position)
  _has_bits_[0] &= ~0x00000001u;
  ::Protocol::Vector* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Protocol::Vector* Move::_internal_mutable_position() {
  _has_bits_[0] |= 0x00000001u;
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::Protocol::Vector* Move::mutable_position() {
  // @@protoc_insertion_point(field_mutable:Protocol.Move.position)
  return _internal_mutable_position();
}
inline void Move::set_allocated_position(::Protocol::Vector* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Protocol::Vector>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Protocol.Move.position)
}

// optional .Protocol.Vector rotation = 5;
inline bool Move::_internal_has_rotation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || rotation_ != nullptr);
  return value;
}
inline bool Move::has_rotation() const {
  return _internal_has_rotation();
}
inline void Move::clear_rotation() {
  if (rotation_ != nullptr) rotation_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Protocol::Vector& Move::_internal_rotation() const {
  const ::Protocol::Vector* p = rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector&>(
      ::Protocol::_Vector_default_instance_);
}
inline const ::Protocol::Vector& Move::rotation() const {
  // @@protoc_insertion_point(field_get:Protocol.Move.rotation)
  return _internal_rotation();
}
inline void Move::unsafe_arena_set_allocated_rotation(
    ::Protocol::Vector* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  rotation_ = rotation;
  if (rotation) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.Move.rotation)
}
inline ::Protocol::Vector* Move::release_rotation() {
  _has_bits_[0] &= ~0x00000002u;
  ::Protocol::Vector* temp = rotation_;
  rotation_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::Vector* Move::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:Protocol.Move.rotation)
  _has_bits_[0] &= ~0x00000002u;
  ::Protocol::Vector* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::Protocol::Vector* Move::_internal_mutable_rotation() {
  _has_bits_[0] |= 0x00000002u;
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector>(GetArenaForAllocation());
    rotation_ = p;
  }
  return rotation_;
}
inline ::Protocol::Vector* Move::mutable_rotation() {
  // @@protoc_insertion_point(field_mutable:Protocol.Move.rotation)
  return _internal_mutable_rotation();
}
inline void Move::set_allocated_rotation(::Protocol::Vector* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Protocol::Vector>::GetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:Protocol.Move.rotation)
}

// -------------------------------------------------------------------

// MoveData

// int64 time = 1;
inline void MoveData::clear_time() {
  time_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MoveData::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MoveData::time() const {
  // @@protoc_insertion_point(field_get:Protocol.MoveData.time)
  return _internal_time();
}
inline void MoveData::_internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  time_ = value;
}
inline void MoveData::set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:Protocol.MoveData.time)
}

// repeated .Protocol.Move move = 2;
inline int MoveData::_internal_move_size() const {
  return move_.size();
}
inline int MoveData::move_size() const {
  return _internal_move_size();
}
inline void MoveData::clear_move() {
  move_.Clear();
}
inline ::Protocol::Move* MoveData::mutable_move(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.MoveData.move)
  return move_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Move >*
MoveData::mutable_move() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.MoveData.move)
  return &move_;
}
inline const ::Protocol::Move& MoveData::_internal_move(int index) const {
  return move_.Get(index);
}
inline const ::Protocol::Move& MoveData::move(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.MoveData.move)
  return _internal_move(index);
}
inline ::Protocol::Move* MoveData::_internal_add_move() {
  return move_.Add();
}
inline ::Protocol::Move* MoveData::add_move() {
  // @@protoc_insertion_point(field_add:Protocol.MoveData.move)
  return _internal_add_move();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Move >&
MoveData::move() const {
  // @@protoc_insertion_point(field_list:Protocol.MoveData.move)
  return move_;
}

// -------------------------------------------------------------------

// Obtacle

// int64 id = 1;
inline void Obtacle::clear_id() {
  id_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Obtacle::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Obtacle::id() const {
  // @@protoc_insertion_point(field_get:Protocol.Obtacle.id)
  return _internal_id();
}
inline void Obtacle::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void Obtacle::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.Obtacle.id)
}

// int32 shape = 2;
inline void Obtacle::clear_shape() {
  shape_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Obtacle::_internal_shape() const {
  return shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Obtacle::shape() const {
  // @@protoc_insertion_point(field_get:Protocol.Obtacle.shape)
  return _internal_shape();
}
inline void Obtacle::_internal_set_shape(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  shape_ = value;
}
inline void Obtacle::set_shape(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_shape(value);
  // @@protoc_insertion_point(field_set:Protocol.Obtacle.shape)
}

// optional .Protocol.Vector position = 3;
inline bool Obtacle::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || position_ != nullptr);
  return value;
}
inline bool Obtacle::has_position() const {
  return _internal_has_position();
}
inline void Obtacle::clear_position() {
  if (position_ != nullptr) position_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Protocol::Vector& Obtacle::_internal_position() const {
  const ::Protocol::Vector* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector&>(
      ::Protocol::_Vector_default_instance_);
}
inline const ::Protocol::Vector& Obtacle::position() const {
  // @@protoc_insertion_point(field_get:Protocol.Obtacle.position)
  return _internal_position();
}
inline void Obtacle::unsafe_arena_set_allocated_position(
    ::Protocol::Vector* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.Obtacle.position)
}
inline ::Protocol::Vector* Obtacle::release_position() {
  _has_bits_[0] &= ~0x00000001u;
  ::Protocol::Vector* temp = position_;
  position_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::Vector* Obtacle::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:Protocol.Obtacle.position)
  _has_bits_[0] &= ~0x00000001u;
  ::Protocol::Vector* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Protocol::Vector* Obtacle::_internal_mutable_position() {
  _has_bits_[0] |= 0x00000001u;
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::Protocol::Vector* Obtacle::mutable_position() {
  // @@protoc_insertion_point(field_mutable:Protocol.Obtacle.position)
  return _internal_mutable_position();
}
inline void Obtacle::set_allocated_position(::Protocol::Vector* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Protocol::Vector>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Protocol.Obtacle.position)
}

// optional .Protocol.Vector rotation = 4;
inline bool Obtacle::_internal_has_rotation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || rotation_ != nullptr);
  return value;
}
inline bool Obtacle::has_rotation() const {
  return _internal_has_rotation();
}
inline void Obtacle::clear_rotation() {
  if (rotation_ != nullptr) rotation_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Protocol::Vector& Obtacle::_internal_rotation() const {
  const ::Protocol::Vector* p = rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector&>(
      ::Protocol::_Vector_default_instance_);
}
inline const ::Protocol::Vector& Obtacle::rotation() const {
  // @@protoc_insertion_point(field_get:Protocol.Obtacle.rotation)
  return _internal_rotation();
}
inline void Obtacle::unsafe_arena_set_allocated_rotation(
    ::Protocol::Vector* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  rotation_ = rotation;
  if (rotation) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.Obtacle.rotation)
}
inline ::Protocol::Vector* Obtacle::release_rotation() {
  _has_bits_[0] &= ~0x00000002u;
  ::Protocol::Vector* temp = rotation_;
  rotation_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::Vector* Obtacle::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:Protocol.Obtacle.rotation)
  _has_bits_[0] &= ~0x00000002u;
  ::Protocol::Vector* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::Protocol::Vector* Obtacle::_internal_mutable_rotation() {
  _has_bits_[0] |= 0x00000002u;
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector>(GetArenaForAllocation());
    rotation_ = p;
  }
  return rotation_;
}
inline ::Protocol::Vector* Obtacle::mutable_rotation() {
  // @@protoc_insertion_point(field_mutable:Protocol.Obtacle.rotation)
  return _internal_mutable_rotation();
}
inline void Obtacle::set_allocated_rotation(::Protocol::Vector* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Protocol::Vector>::GetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:Protocol.Obtacle.rotation)
}

// float speed = 5;
inline void Obtacle::clear_speed() {
  speed_ = 0;
}
inline float Obtacle::_internal_speed() const {
  return speed_;
}
inline float Obtacle::speed() const {
  // @@protoc_insertion_point(field_get:Protocol.Obtacle.speed)
  return _internal_speed();
}
inline void Obtacle::_internal_set_speed(float value) {
  
  speed_ = value;
}
inline void Obtacle::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:Protocol.Obtacle.speed)
}

// int32 direction = 6;
inline void Obtacle::clear_direction() {
  direction_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Obtacle::_internal_direction() const {
  return direction_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Obtacle::direction() const {
  // @@protoc_insertion_point(field_get:Protocol.Obtacle.direction)
  return _internal_direction();
}
inline void Obtacle::_internal_set_direction(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  direction_ = value;
}
inline void Obtacle::set_direction(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:Protocol.Obtacle.direction)
}

// -------------------------------------------------------------------

// Player

// int64 id = 1;
inline void Player::clear_id() {
  id_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Player::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Player::id() const {
  // @@protoc_insertion_point(field_get:Protocol.Player.id)
  return _internal_id();
}
inline void Player::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void Player::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.Player.id)
}

// optional .Protocol.Vector position = 2;
inline bool Player::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || position_ != nullptr);
  return value;
}
inline bool Player::has_position() const {
  return _internal_has_position();
}
inline void Player::clear_position() {
  if (position_ != nullptr) position_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Protocol::Vector& Player::_internal_position() const {
  const ::Protocol::Vector* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector&>(
      ::Protocol::_Vector_default_instance_);
}
inline const ::Protocol::Vector& Player::position() const {
  // @@protoc_insertion_point(field_get:Protocol.Player.position)
  return _internal_position();
}
inline void Player::unsafe_arena_set_allocated_position(
    ::Protocol::Vector* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.Player.position)
}
inline ::Protocol::Vector* Player::release_position() {
  _has_bits_[0] &= ~0x00000001u;
  ::Protocol::Vector* temp = position_;
  position_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::Vector* Player::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:Protocol.Player.position)
  _has_bits_[0] &= ~0x00000001u;
  ::Protocol::Vector* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Protocol::Vector* Player::_internal_mutable_position() {
  _has_bits_[0] |= 0x00000001u;
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::Protocol::Vector* Player::mutable_position() {
  // @@protoc_insertion_point(field_mutable:Protocol.Player.position)
  return _internal_mutable_position();
}
inline void Player::set_allocated_position(::Protocol::Vector* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Protocol::Vector>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Protocol.Player.position)
}

// optional .Protocol.Vector rotation = 3;
inline bool Player::_internal_has_rotation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || rotation_ != nullptr);
  return value;
}
inline bool Player::has_rotation() const {
  return _internal_has_rotation();
}
inline void Player::clear_rotation() {
  if (rotation_ != nullptr) rotation_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Protocol::Vector& Player::_internal_rotation() const {
  const ::Protocol::Vector* p = rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector&>(
      ::Protocol::_Vector_default_instance_);
}
inline const ::Protocol::Vector& Player::rotation() const {
  // @@protoc_insertion_point(field_get:Protocol.Player.rotation)
  return _internal_rotation();
}
inline void Player::unsafe_arena_set_allocated_rotation(
    ::Protocol::Vector* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  rotation_ = rotation;
  if (rotation) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.Player.rotation)
}
inline ::Protocol::Vector* Player::release_rotation() {
  _has_bits_[0] &= ~0x00000002u;
  ::Protocol::Vector* temp = rotation_;
  rotation_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::Vector* Player::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:Protocol.Player.rotation)
  _has_bits_[0] &= ~0x00000002u;
  ::Protocol::Vector* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::Protocol::Vector* Player::_internal_mutable_rotation() {
  _has_bits_[0] |= 0x00000002u;
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector>(GetArenaForAllocation());
    rotation_ = p;
  }
  return rotation_;
}
inline ::Protocol::Vector* Player::mutable_rotation() {
  // @@protoc_insertion_point(field_mutable:Protocol.Player.rotation)
  return _internal_mutable_rotation();
}
inline void Player::set_allocated_rotation(::Protocol::Vector* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Protocol::Vector>::GetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:Protocol.Player.rotation)
}

// -------------------------------------------------------------------

// PlayerCrash

// int64 id = 1;
inline void PlayerCrash::clear_id() {
  id_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerCrash::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerCrash::id() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerCrash.id)
  return _internal_id();
}
inline void PlayerCrash::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void PlayerCrash::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerCrash.id)
}

// .Protocol.Vector position = 2;
inline bool PlayerCrash::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool PlayerCrash::has_position() const {
  return _internal_has_position();
}
inline void PlayerCrash::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::Protocol::Vector& PlayerCrash::_internal_position() const {
  const ::Protocol::Vector* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector&>(
      ::Protocol::_Vector_default_instance_);
}
inline const ::Protocol::Vector& PlayerCrash::position() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerCrash.position)
  return _internal_position();
}
inline void PlayerCrash::unsafe_arena_set_allocated_position(
    ::Protocol::Vector* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerCrash.position)
}
inline ::Protocol::Vector* PlayerCrash::release_position() {
  
  ::Protocol::Vector* temp = position_;
  position_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::Vector* PlayerCrash::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerCrash.position)
  
  ::Protocol::Vector* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Protocol::Vector* PlayerCrash::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::Protocol::Vector* PlayerCrash::mutable_position() {
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerCrash.position)
  return _internal_mutable_position();
}
inline void PlayerCrash::set_allocated_position(::Protocol::Vector* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Protocol::Vector>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerCrash.position)
}

// .Protocol.Vector rotation = 3;
inline bool PlayerCrash::_internal_has_rotation() const {
  return this != internal_default_instance() && rotation_ != nullptr;
}
inline bool PlayerCrash::has_rotation() const {
  return _internal_has_rotation();
}
inline void PlayerCrash::clear_rotation() {
  if (GetArenaForAllocation() == nullptr && rotation_ != nullptr) {
    delete rotation_;
  }
  rotation_ = nullptr;
}
inline const ::Protocol::Vector& PlayerCrash::_internal_rotation() const {
  const ::Protocol::Vector* p = rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector&>(
      ::Protocol::_Vector_default_instance_);
}
inline const ::Protocol::Vector& PlayerCrash::rotation() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerCrash.rotation)
  return _internal_rotation();
}
inline void PlayerCrash::unsafe_arena_set_allocated_rotation(
    ::Protocol::Vector* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerCrash.rotation)
}
inline ::Protocol::Vector* PlayerCrash::release_rotation() {
  
  ::Protocol::Vector* temp = rotation_;
  rotation_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::Vector* PlayerCrash::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerCrash.rotation)
  
  ::Protocol::Vector* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::Protocol::Vector* PlayerCrash::_internal_mutable_rotation() {
  
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector>(GetArenaForAllocation());
    rotation_ = p;
  }
  return rotation_;
}
inline ::Protocol::Vector* PlayerCrash::mutable_rotation() {
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerCrash.rotation)
  return _internal_mutable_rotation();
}
inline void PlayerCrash::set_allocated_rotation(::Protocol::Vector* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Protocol::Vector>::GetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerCrash.rotation)
}

// .Protocol.Player enemy = 4;
inline bool PlayerCrash::_internal_has_enemy() const {
  return this != internal_default_instance() && enemy_ != nullptr;
}
inline bool PlayerCrash::has_enemy() const {
  return _internal_has_enemy();
}
inline void PlayerCrash::clear_enemy() {
  if (GetArenaForAllocation() == nullptr && enemy_ != nullptr) {
    delete enemy_;
  }
  enemy_ = nullptr;
}
inline const ::Protocol::Player& PlayerCrash::_internal_enemy() const {
  const ::Protocol::Player* p = enemy_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Player&>(
      ::Protocol::_Player_default_instance_);
}
inline const ::Protocol::Player& PlayerCrash::enemy() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerCrash.enemy)
  return _internal_enemy();
}
inline void PlayerCrash::unsafe_arena_set_allocated_enemy(
    ::Protocol::Player* enemy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enemy_);
  }
  enemy_ = enemy;
  if (enemy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerCrash.enemy)
}
inline ::Protocol::Player* PlayerCrash::release_enemy() {
  
  ::Protocol::Player* temp = enemy_;
  enemy_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::Player* PlayerCrash::unsafe_arena_release_enemy() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerCrash.enemy)
  
  ::Protocol::Player* temp = enemy_;
  enemy_ = nullptr;
  return temp;
}
inline ::Protocol::Player* PlayerCrash::_internal_mutable_enemy() {
  
  if (enemy_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Player>(GetArenaForAllocation());
    enemy_ = p;
  }
  return enemy_;
}
inline ::Protocol::Player* PlayerCrash::mutable_enemy() {
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerCrash.enemy)
  return _internal_mutable_enemy();
}
inline void PlayerCrash::set_allocated_enemy(::Protocol::Player* enemy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete enemy_;
  }
  if (enemy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Protocol::Player>::GetOwningArena(enemy);
    if (message_arena != submessage_arena) {
      enemy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enemy, submessage_arena);
    }
    
  } else {
    
  }
  enemy_ = enemy;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerCrash.enemy)
}

// -------------------------------------------------------------------

// Vector

// float x = 1;
inline void Vector::clear_x() {
  x_ = 0;
}
inline float Vector::_internal_x() const {
  return x_;
}
inline float Vector::x() const {
  // @@protoc_insertion_point(field_get:Protocol.Vector.x)
  return _internal_x();
}
inline void Vector::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Vector::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.Vector.x)
}

// float y = 2;
inline void Vector::clear_y() {
  y_ = 0;
}
inline float Vector::_internal_y() const {
  return y_;
}
inline float Vector::y() const {
  // @@protoc_insertion_point(field_get:Protocol.Vector.y)
  return _internal_y();
}
inline void Vector::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Vector::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.Vector.y)
}

// float z = 3;
inline void Vector::clear_z() {
  z_ = 0;
}
inline float Vector::_internal_z() const {
  return z_;
}
inline float Vector::z() const {
  // @@protoc_insertion_point(field_get:Protocol.Vector.z)
  return _internal_z();
}
inline void Vector::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Vector::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.Vector.z)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Protocol::INGAME> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::INGAME>() {
  return ::Protocol::INGAME_descriptor();
}
template <> struct is_proto_enum< ::Protocol::Animation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::Animation>() {
  return ::Protocol::Animation_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ProtocolServer_2eproto
